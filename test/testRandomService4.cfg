process TEST4 = {

  // This is an example of how to restore the random engine states
  // in order to reproduce the sequence of random numbers in all the
  // modules.

  // Use as input a file that contains the stored random engine
  // states.
  source = PoolSource {
    untracked vstring fileNames = {"file:testRandomService1.root"}

    // For example, say you are interested in reproducing the process for
    // the third event without wasting time to reprocess the rest.
    // (Alternately, one could strip out this event into a separate
    // file.)
    untracked uint32 firstRun   = 1
    untracked uint32 firstEvent = 3
  }

  untracked PSet maxEvents = {
    untracked int32 input = 1
  }

  service = RandomNumberGeneratorService {
 
    // This line causes the random state to be restored.
    // The value is the module label from the previous process
    // of the producer that saved the random engine state
#   untracked string restoreStateLabel = "randomEngineStateProducer"

    // COMMENT OUT OR DELETE the lines that assign seed(s) to
    // the source.  The ability to restore the state of the
    // random engine used by the source has not been implemented
    // yet.  Currently, an exception will be thrown if one
    // supplies seeds for the source in the configuration
    // file AND tries to restore the random engine states
    // in the same process.
    // untracked uint32 sourceSeed = 181
    // untracked vuint32 sourceSeedVector = { 7, 11 }
    // untracked string sourceEngine = "RanecuEngine"

    // Tell the service to restore engine states from the
    // file written by a previous run
    untracked string restoreFileName = "StashState.data"

    // Tell the service to store the engine states per event
    untracked string saveFileName    = "StashState.data"

    // Normally the rest of the parameters for the service will
    // be identical to the previous process. Here we express
    // all the same engines and seeds as in testRandomService3.cfg
    // except that they are given in the alternate form.
    
    // Default engine to JamesRandom
    PSet t1 = {
      untracked uint32 initialSeed = 81
    }

    PSet t2 = {
      untracked string engineName = "RanecuEngine"
      untracked vuint32 initialSeedSet = { 1, 2 }
    }

    PSet t3 = {
      untracked string engineName = "TRandom3"
      untracked uint32 initialSeed = 83
    }

    // Again default engine to JamesRandom
    PSet t4 = {
      untracked uint32 initialSeed = 84
    }

    // TRandom3 only needs a single seed but we give
    // a seed set.  The service takes the first entry
    // and ignores the rest.  Note that there is no 
    // module with label t5.  Nevertheless, this PSet
    // needs to be here because it appears in the save 
    // file from the previous run and this cfg and that
    // save file must match.
    PSet t5 = {
      untracked string engineName = "TRandom3"
      untracked vuint32 initialSeedSet = { 193, 197 }
    }
  }

  module t1 = TestRandomNumberServiceAnalyzer { }
  module t2 = TestRandomNumberServiceAnalyzer { }
  module t3 = TestRandomNumberServiceAnalyzer { }
  module t4 = TestRandomNumberServiceAnalyzer { }

  path p = { t1 & t2 & t3 & t4 }

  // It is legal to have additional modules or less modules
  // with or without random numbers configured, but if you do
  // they simply will not get their engine state restored.  There
  // may be complicated situations where you want that, although
  // if you are simply reproducing what you did before it is
  // not relevant.  The algorithm in the service looks for module
  // labels that match and restores the random engine state for
  // those, ignoring the rest.

  // I've deleted the commands that produce an output file
  // and store the random states in the event.
  // Normally, when you restore the random engine state you
  // will not need to do that.  But if anyone
  // wants to do this, it is not illegal.  Just give the
  // producer a different module label so you can find the saved
  // state later.  If there are two objects with the same label
  // in the event, it is a problem to retrieve the correct one.
}
