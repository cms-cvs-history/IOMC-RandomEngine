process TEST2 = {

  // This is an example of how to restore the random engine states
  // in order to reproduce the sequence of random numbers in all the
  // modules.

  // Use as input a file that contains the stored random engine
  // states.
  source = PoolSource {
    untracked vstring fileNames = {"file:testRandomService1.root"}

    // For example, say you are interested in reproducing the process for
    // the third event without wasting time to reprocess the rest.
    // (Alternately, one could strip out this event into a separate
    // file.)
    untracked uint32 firstRun = 1
#   untracked uint32 firstEvent = 3
  }

  untracked PSet maxEvents = {
#   untracked int32 input = 1
    untracked int32 input = 5
  }

  service = RandomNumberGeneratorService {
 
    // This line causes the random state to be restored.
    // The value is the module label from the previous process
    // of the producer that saved the random engine state
    untracked string restoreStateLabel = "randomEngineStateProducer"

    // COMMENT OUT OR DELETE the lines that assign seed(s) to
    // the source.  The ability to restore the state of the
    // random engine used by the source has not been implemented
    // yet.  Currently, an exception will be thrown if one
    // supplies seeds for the source in the configuration
    // file AND tries to restore the random engine states
    // in the same process.
    // untracked uint32 sourceSeed = 181
    // untracked vuint32 sourceSeedVector = { 7, 11 }
    // untracked string sourceEngine = "RanecuEngine"

    // Tell the service to restore engine states from the
    // file written by a previous run
    untracked string restoreFileName = "StashState.data"

    // Tell the service to store the engine states per event
    untracked string saveFileName    = "StashState.data"

    // Normally the rest of the parameters for the service will
    // be identical to the previous process (here they are copied
    // from testRandomService1.cfg)
    PSet moduleSeeds = {
      untracked uint32 t1 = 81
      untracked uint32 t3 = 83
      untracked uint32 t4 = 84      
    }
    PSet moduleSeedVectors = {
      untracked vuint32 t2 = { 1, 2 }     
    }
    PSet moduleEngines = {
      untracked string t2 = "RanecuEngine"
      untracked string t3 = "TRandom3"
    }
  }

  module t1 = TestRandomNumberServiceAnalyzer { }
  module t2 = TestRandomNumberServiceAnalyzer { }
  module t3 = TestRandomNumberServiceAnalyzer { }
  module t4 = TestRandomNumberServiceAnalyzer { }

  path p = { t1 & t2 & t3 & t4 }

  // It is legal to have additional modules or less modules
  // with or without random numbers configured, but if you do
  // they simply will not get their engine state restored.  There
  // may be complicated situations where you want that, although
  // if you are simply reproducing what you did before it is
  // not relevant.  The algorithm in the service looks for module
  // labels that match and restores the random engine state for
  // those, ignoring the rest.

  // I've deleted the commands that produce an output file
  // and store the random states in the event.
  // Normally, when you restore the random engine state you
  // will not need to do that.  But if anyone
  // wants to do this, it is not illegal.  Just give the
  // producer a different module label so you can find the saved
  // state later.  If there are two objects with the same label
  // in the event, it is a problem to retrieve the correct one.
}
